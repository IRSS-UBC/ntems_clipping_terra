if (!file.exists("C:/Users/evanmuis/Desktop/ntems_cliping_terra/shapefiles/non_overlapping_masks_canada.shp")) {
read_add_crs <- function(shp_path) {
# pulls the ntems zone form name and appends it so when the intersection
# happens it can figure out the zones to process
shp <- shp_path %>%
read_sf()
zone <- tools::file_path_sans_ext(basename(shp_path)) %>%
str_extract("\\d.*") #anything after first digit
shp %>%
mutate(crs = zone)
}
map(shp_files, read_add_crs) %>%
map(st_transform, crs = 3347) %>%
bind_rows() %>%
st_write(here::here("shapefiles", "non_overlapping_masks_canada.shp"), append = F)
rm(read_add_crs)
}
nom_cad <- read_sf(here::here("shapefiles", "non_overlapping_masks_canada.shp"))
mask_rcl <- matrix(c(0, 1,
NA, 1),
ncol = 2)
mask_save_base <- map(masks_files, tools::file_path_sans_ext) %>%
map(basename) %>%
unlist()
mask_save_names <- here::here("shapefiles", paste0(mask_save_base, ".shp"))
if(!all(file.exists(mask_save_names))) {
clean_masks <- map(masks_files, rast) %>%
map(classify, rcl = mask_rcl) %>%
map(as.polygons) %>%
map2(.x = ., .y = mask_save_names, .f = writeVector)
}
utmzone_all <- st_intersection(aoi %>% st_transform(3347), nom_cad %>% st_make_valid()) %>%
pull(crs) %>%
unique() # solves multipart polygon issues
terra_temp <- "D:\\temp_idl" # save in variable because used in ntems_mosaic_gdal()
terraOptions(memfrac = 0.75,
tempdir = terra_temp,
todisk = T,
progress = 100)
#### user inputs ####
aoi_path <- "Z:\\ByUser\\Muise\\hana\\FTE_Extent.shp"
outpath <- dirname(aoi_path) %>%
here::here(tools::file_path_sans_ext(basename(aoi_path)))
# if you want a custom outpath, comment out if you want in the same folder
outpath <- "D:\\Bud\\bc"
#years <- c(1984:2021)
years <- 2015
# what to process?
vars <- tibble(VLCE = T,  #note - VLCE is always required when processing structure layers
proxies = F,
change_attribution = F,
change_metrics = F,
topography = F,
lat = F,
lon = F,
climate = F,
structure_basal_area = F,
structure_elev_cv = F,
structure_elev_mean = F,
structure_elev_p95 = F,
structure_elev_stddev = F,
structure_gross_stem_volume = F,
structure_loreys_height = F,
structure_percentage_first_returns_above_2m = F,
structure_percentage_first_returns_above_mean = F,
structure_total_biomass = F) %>%
pivot_longer(cols = everything()) %>%
filter(value) %>%
pull(name)
# a template raster to project to. currently, if the region is >1 UTM zone, defaults to LCC
template <- rast("D:\\Bud\\template_raster\\CA_forest_VLCE_2015.tif")
template <- rast("Z:\\ByUser\\Muise\\bc-vlce-2015.tif")
#### end user inputs ####
# processing from here on, user not to adjust unless they are confident in what they are doing
aoi <- read_sf(aoi_path)
aoi <- bcmaps::bc_bound_hres()
utmzone_all <- st_intersection(aoi %>% st_transform(3347), nom_cad %>% st_make_valid()) %>%
pull(crs) %>%
unique() # solves multipart polygon issues
valid_zones <- list.files("M:\\VLCE2.0_1984-2021") %>%
str_split("_") %>%
sapply("[", 2)
utmzone_all <- utmzone_all[utmzone_all %in% valid_zones]
print(paste0("AOI is located in ", length(utmzone_all), " UTM zones: "))
print(utmzone_all)
print("Note that letters N or S correspond to the internal NTEMS data division, not northern or southern hemishphere")
if(length(utmzone_all > 1)) {
out_crs = crs(rast(template))
}
# add the m in front so it only detects those it should
# without it, 9S would also detect 19S
utm_masks <- str_subset(mask_save_names, paste(paste0("M", utmzone_all), collapse = "|")) %>%
map(vect)
names(utm_masks) <- utmzone_all
utm_masks
# if single zone, out crs should be that utm zone
out_crs <- st_crs(aoi)
source(here::here("scripts", "get_utm_masks.R")) # generates utmzone_all
source(here::here("scripts", "get_data_type.R")) # function to make sure files save properly, shamelessly stolen from piotr
source(here::here("scripts", "ntems_crop.R"))
utmzone_all <- utmzone_all[endsWith(utmzone_all, "S")]
utm_masks <- utm_masks[endsWith(names(utm_masks), "S")]
to_process <- crossing(year = years, zone = utmzone_all, var = vars)
source(here::here("scripts", "generate_process_df.R"))
# this is just annoying regex to clean up the mosaic output names so we can then
# split based on the mosaic paths to operate on everything using map
# basically, sorry i did this to anyone who tries to read it in post
# i've tried to add human readable comments, but regex is tough
mosaic_dfs <- process_df %>%
mutate(mosaic_path = str_replace(path_out, "[0-9]{1,2}[a-zA-Z]{1}", "mosaiced"),
# regex that checks for 1-2 numbers, the 1 letter, and turns it to mosaiced
mosaic_path = str_replace(mosaic_path, "UTM_[0-9]{1,2}[a-zA-Z]{1}_", ""),
# regex that checks for UTM_ 1-2 numbers, then a letter, then an underscore, and removes it
mosaic_path = str_replace(mosaic_path, "UTM[0-9]{1,2}[a-zA-Z]{1}_", ""),
# regex that checks for UTM 1-2 numbers, then a letter, then and underscore, and removes it
mosaic_path = str_replace(mosaic_path, "_[0-9]{1,2}[a-zA-Z]{1}_", "_")
# regex that checks for an underscore, 1-2 numbers, a letter, underscore, and replaces with an underscore
) %>%
group_split(mosaic_path)
tibble <- mosaic_dfs[[1]]
mosaic_start <- Sys.time()
year <- tibble %>%
pull(year) %>%
unique()
var <- tibble %>%
pull(var) %>%
unique()
save_path <- tibble %>%
pull(mosaic_path) %>%
unique()
print("mosaicing ------------------")
print(paste("zones:", toString(utmzone_all)))
print(paste("year:", year))
print(paste("variable:", var))
print(paste("save path:", save_path))
dir.create(dirname(save_path), showWarnings = F, recursive = T)
ref <- tibble %>%
head(1) %>%
pull(path_out)
dtype <- ref %>%
get_data_type()
print(paste("datatype:", dtype))
#print(paste("mosaicing at: ", save_path))
print("----------------------------")
rasts <- tibble %>%
pull(path_out) %>%
map(rast)
?project
utm_masks_proj <- utm_masks %>%
map(project, y = template)
utm_masks_proj <- utm_masks %>%
map(project, y = template)
template
?project
rasts_proj <- rasts %>%
map(project, y = template)
rasts_mask %>%
map(mask, y = utm_masks_proj)
rasts_mask <- rasts_proj %>%
map(mask, y = utm_masks_proj)
utm_masks_proj
rasts_proj
rasts_mask <- rasts_proj %>%
map(mask, y = utm_masks_proj)
?mask
rasts_mask <- rasts_proj %>%
map2(.x = ., .y = utm_masks_proj, mask)
# temp file locations
terra_temp <- "D:\\temp_idl3" # save in variable because used in ntems_mosaic_gdal()
terraOptions(memfrac = 0.75,
tempdir = terra_temp,
todisk = T,
progress = 100)
rasts_mask <- rasts_proj %>%
map2(.x = ., .y = utm_masks_proj, mask)
source("C:/Users/evanmuis/Desktop/ntems_cliping_terra/scripts/whole_game_bc.R", echo=TRUE)
# temp file locations
terra_temp <- "D:\\temp_idl3" # save in variable because used in ntems_mosaic_gdal()
terraOptions(memfrac = 0.75,
tempdir = terra_temp,
#todisk = T,
progress = 100)
masked_data
rasts_proj
tibble <- mosaic_dfs[[1]]
mosaic_start <- Sys.time()
year <- tibble %>%
pull(year) %>%
unique()
var <- tibble %>%
pull(var) %>%
unique()
save_path <- tibble %>%
pull(mosaic_path) %>%
unique()
print("mosaicing ------------------")
print(paste("zones:", toString(utmzone_all)))
print(paste("year:", year))
print(paste("variable:", var))
print(paste("save path:", save_path))
dir.create(dirname(save_path), showWarnings = F, recursive = T)
ref <- tibble %>%
head(1) %>%
pull(path_out)
dtype <- ref %>%
get_data_type()
print(paste("datatype:", dtype))
#print(paste("mosaicing at: ", save_path))
print("----------------------------")
rasts <- tibble %>%
pull(path_out) %>%
map(rast)
print("Projecting rasters and vector masks")
utm_masks_proj <- utm_masks %>%
map(project, y = template)
rasts_proj <- rasts %>%
map(project, y = template)
print("Masking rasters on vectors masks")
masked_data <- rasts_proj %>%
map2(.x = ., .y = utm_masks_proj, mask)
# mask_fnames <- here::here(outpath, "mosaiced", "UTM_mask", utmzone_all, paste0("UTM_mask_", utmzone_all, "_LCC.dat"))
#
# if(!all(file.exists(mask_fnames))) {
#   print("Creating masks")
#
#   map(here::here(outpath, "mosaiced", "UTM_mask", utmzone_all), dir.create,
#       showWarnings = F, recursive = T)
#
#   exts <- rasts %>%
#     map(ext) %>%
#     map2(.x = ., .y = map(rasts, crs), .f = as.polygons) %>%
#     map2(.x = ., .y = utm_masks, .f = project)
#
#   cropped_masks <- map2(.x = utm_masks, .y = exts, .f = crop)
#
#   map2(.x = cropped_masks, .y = mask_fnames, .f = writeRaster,
#        filetype = "envi", overwrite = T)
#
# } else {
#   print("Loading masks")
#   cropped_masks <- map(mask_fnames, rast)
#
# }
#
# print("Projecting, cropping rasters")
#
# proj_rasts <- rasts %>%
#   map2(.x = ., .y = cropped_masks, .f = project,
#        align = T, method = "near")
#
#
# proj_crop_rasts <- proj_rasts %>%
#   map2(.x = ., .y = cropped_masks, .f = crop)
#
# print("Masking data")
#
# masked_data <- map2(.x = proj_crop_rasts, .y = cropped_masks, .f = mask,
#                    maskvalue = 0)
print("Mosaicing")
mosaiced <- masked_data %>%
sprc() %>%
mosaic()
print("Mosaiced")
if (var == "VLCE" | var == "change_attribution") {
# implement a direct header modification here
print("Adding levels and colours")
levels(mosaiced) <- levels(rast(ref))
coltab(mosaiced) <- coltab(rast(ref))
}
print("Saving")
writeRaster(mosaiced, filename = save_path,
datatype = dtype,
filetype = "ENVI",
overwrite = T,
todisk = T,
memfrac = 0.75)
mosaiced <- masked_data %>%
sprc() %>%
mosaic()
masked_data
masked_data <- rasts_proj %>%
map2(.x = ., .y = utm_masks_proj, mask, todisk = F)
tempdir
terra::tmpFiles(remove = T)
terra::tmpFiles
terra::tmpFiles()
start_time <- Sys.time()
library("tidyverse")
library("terra")
library("sf")
# temp file locations
terra_temp <- "D:\\temp_idl3" # save in variable because used in ntems_mosaic_gdal()
terraOptions(memfrac = 0.75,
tempdir = terra_temp,
todisk = T,
progress = 100)
#### user inputs ####
aoi_path <- "Z:\\ByUser\\Muise\\hana\\FTE_Extent.shp"
outpath <- dirname(aoi_path) %>%
here::here(tools::file_path_sans_ext(basename(aoi_path)))
# if you want a custom outpath, comment out if you want in the same folder
outpath <- "D:\\Bud\\bc"
#years <- c(1984:2021)
years <- 2015
# what to process?
vars <- tibble(VLCE = T,  #note - VLCE is always required when processing structure layers
proxies = F,
change_attribution = F,
change_metrics = F,
topography = F,
lat = F,
lon = F,
climate = F,
structure_basal_area = F,
structure_elev_cv = F,
structure_elev_mean = F,
structure_elev_p95 = F,
structure_elev_stddev = F,
structure_gross_stem_volume = F,
structure_loreys_height = F,
structure_percentage_first_returns_above_2m = F,
structure_percentage_first_returns_above_mean = F,
structure_total_biomass = F) %>%
pivot_longer(cols = everything()) %>%
filter(value) %>%
pull(name)
# a template raster to project to. currently, if the region is >1 UTM zone, defaults to LCC
template <- rast("D:\\Bud\\template_raster\\CA_forest_VLCE_2015.tif")
template <- rast("Z:\\ByUser\\Muise\\bc-vlce-2015.tif")
#### end user inputs ####
# processing from here on, user not to adjust unless they are confident in what they are doing
aoi <- read_sf(aoi_path)
aoi <- bcmaps::bc_bound_hres()
# if single zone, out crs should be that utm zone
out_crs <- st_crs(aoi)
source(here::here("scripts", "get_utm_masks.R")) # generates utmzone_all
source(here::here("scripts", "get_data_type.R")) # function to make sure files save properly, shamelessly stolen from piotr
source(here::here("scripts", "ntems_crop.R"))
utmzone_all <- utmzone_all[endsWith(utmzone_all, "S")]
utm_masks <- utm_masks[endsWith(names(utm_masks), "S")]
to_process <- crossing(year = years, zone = utmzone_all, var = vars)
source(here::here("scripts", "generate_process_df.R"))
# this is just annoying regex to clean up the mosaic output names so we can then
# split based on the mosaic paths to operate on everything using map
# basically, sorry i did this to anyone who tries to read it in post
# i've tried to add human readable comments, but regex is tough
mosaic_dfs <- process_df %>%
mutate(mosaic_path = str_replace(path_out, "[0-9]{1,2}[a-zA-Z]{1}", "mosaiced"),
# regex that checks for 1-2 numbers, the 1 letter, and turns it to mosaiced
mosaic_path = str_replace(mosaic_path, "UTM_[0-9]{1,2}[a-zA-Z]{1}_", ""),
# regex that checks for UTM_ 1-2 numbers, then a letter, then an underscore, and removes it
mosaic_path = str_replace(mosaic_path, "UTM[0-9]{1,2}[a-zA-Z]{1}_", ""),
# regex that checks for UTM 1-2 numbers, then a letter, then and underscore, and removes it
mosaic_path = str_replace(mosaic_path, "_[0-9]{1,2}[a-zA-Z]{1}_", "_")
# regex that checks for an underscore, 1-2 numbers, a letter, underscore, and replaces with an underscore
) %>%
group_split(mosaic_path)
source(here::here("scripts", "ntems_mosaic.R"))
map(mosaic_dfs, ntems_mosaicer)
source("C:/Users/evanmuis/Desktop/ntems_cliping_terra/scripts/whole_game_bc.R", echo=TRUE)
tempdir
names(rasts_proj)
utm_masks_proj
tibble <- mosaic_dfs[[1]]
tibble
mosaic_start <- Sys.time()
year <- tibble %>%
pull(year) %>%
unique()
var <- tibble %>%
pull(var) %>%
unique()
tibble <- head(tibble2)
tibble <- head(tibble, 2)
tibble
year <- tibble %>%
pull(year) %>%
unique()
var <- tibble %>%
pull(var) %>%
unique()
save_path <- tibble %>%
pull(mosaic_path) %>%
unique()
print("mosaicing ------------------")
print(paste("zones:", toString(utmzone_all)))
print(paste("year:", year))
print(paste("variable:", var))
print(paste("save path:", save_path))
dir.create(dirname(save_path), showWarnings = F, recursive = T)
ref <- tibble %>%
head(1) %>%
pull(path_out)
dtype <- ref %>%
get_data_type()
print(paste("datatype:", dtype))
#print(paste("mosaicing at: ", save_path))
print("----------------------------")
rasts <- tibble %>%
pull(path_out) %>%
map(rast)
print("Projecting rasters and vector masks")
utm_masks_proj <- utm_masks %>%
map(project, y = template)
rasts_proj <- rasts %>%
map(project, y = template)
tibble
print("Masking rasters on vectors masks")
masked_data <- rasts_proj %>%
map2(.x = ., .y = utm_masks_proj, .f = mask)
masked_data <- rasts_proj %>%
map2(.x = ., .y = utm_masks_proj[[1:2]], .f = mask)
utm_masks_proj
masked_data <- rasts_proj %>%
map2(.x = ., .y = utm_masks_proj[1:2], .f = mask)
?possibly
print(years, "test")
print(years)
?terra::crop
start_time <- Sys.time()
library("tidyverse")
library("terra")
library("sf")
# temp file locations
terra_temp <- "D:\\temp_idl3" # save in variable because used in ntems_mosaic_gdal()
terraOptions(memfrac = 0.75,
tempdir = terra_temp,
# todisk = T,
progress = 100)
#### user inputs ####
aoi_path <- "Z:\\ByUser\\Muise\\hana\\FTE_Extent.shp"
outpath <- dirname(aoi_path) %>%
here::here(tools::file_path_sans_ext(basename(aoi_path)))
# if you want a custom outpath, comment out if you want in the same folder
outpath <- "D:\\Bud\\bc"
dir.create(here::here(outpath, "scratch"))
#years <- c(1984:2021)
years <- 2015
# what to process?
vars <- tibble(VLCE = T,  #note - VLCE is always required when processing structure layers
proxies = F,
change_attribution = T,
change_metrics = T,
topography = T,
lat = T,
lon = T,
climate = T,
structure_basal_area = T,
structure_elev_cv = T,
structure_elev_mean = T,
structure_elev_p95 = T,
structure_elev_stddev = T,
structure_gross_stem_volume = T,
structure_loreys_height = T,
structure_percentage_first_returns_above_2m = T,
structure_percentage_first_returns_above_mean = T,
structure_total_biomass = T) %>%
pivot_longer(cols = everything()) %>%
filter(value) %>%
pull(name)
# a template raster to project to. currently, if the region is >1 UTM zone, defaults to LCC
template <- rast("D:\\Bud\\template_raster\\CA_forest_VLCE_2015.tif")
template <- rast("Z:\\ByUser\\Muise\\bc-vlce-2015.tif")
#### end user inputs ####
# processing from here on, user not to adjust unless they are confident in what they are doing
aoi <- read_sf(aoi_path)
aoi <- bcmaps::bc_bound_hres()
# if single zone, out crs should be that utm zone
out_crs <- st_crs(aoi)
source(here::here("scripts", "get_utm_masks.R")) # generates utmzone_all
source(here::here("scripts", "get_data_type.R")) # function to make sure files save properly, shamelessly stolen from piotr
source(here::here("scripts", "ntems_crop.R"))
utmzone_all <- utmzone_all[endsWith(utmzone_all, "S")]
utm_masks <- utm_masks[endsWith(names(utm_masks), "S")]
to_process <- crossing(year = years, zone = utmzone_all, var = vars)
source(here::here("scripts", "generate_process_df.R"))
# this is just annoying regex to clean up the mosaic output names so we can then
# split based on the mosaic paths to operate on everything using map
# basically, sorry i did this to anyone who tries to read it in post
# i've tried to add human readable comments, but regex is tough
mosaic_dfs <- process_df %>%
mutate(mosaic_path = str_replace(path_out, "[0-9]{1,2}[a-zA-Z]{1}", "mosaiced"),
# regex that checks for 1-2 numbers, the 1 letter, and turns it to mosaiced
mosaic_path = str_replace(mosaic_path, "UTM_[0-9]{1,2}[a-zA-Z]{1}_", ""),
# regex that checks for UTM_ 1-2 numbers, then a letter, then an underscore, and removes it
mosaic_path = str_replace(mosaic_path, "UTM[0-9]{1,2}[a-zA-Z]{1}_", ""),
# regex that checks for UTM 1-2 numbers, then a letter, then and underscore, and removes it
mosaic_path = str_replace(mosaic_path, "_[0-9]{1,2}[a-zA-Z]{1}_", "_")
# regex that checks for an underscore, 1-2 numbers, a letter, underscore, and replaces with an underscore
) %>%
group_split(mosaic_path)
mosaic_dfs <- mosaic_dfs[3:length(mosaic_dfs)]
tibble <- mosaic_dfs[[1]]
mosaic_start <- Sys.time()
year <- tibble %>%
pull(year) %>%
unique()
var <- tibble %>%
pull(var) %>%
unique()
save_path <- tibble %>%
pull(mosaic_path) %>%
unique()
print("mosaicing ------------------")
print(paste("zones:", toString(utmzone_all)))
print(paste("year:", year))
print(paste("variable:", var))
print(paste("save path:", save_path))
detach("package:terra", unload = TRUE)
install.packages('terra', repos='https://rspatial.r-universe.dev')
install.packages("terra", repos = "https://rspatial.r-universe.dev")
install.packages("terra", repos = "https://rspatial.r-universe.dev")
